*This page is still under construction*

*Note:* please download the latest version (current: *0.19*) from Downloads tab

<wiki:toc max_depth="3" />


= What is Palus? =

Palus is an automated test generation tool, which combines various static and dynamic analysis to create tests for Java programs in the JUnit form.


= How to use Palus? =

*In short*: see its help manual. 

Execute the following command:

java -cp ./palus-0.1.jar:./asm-all-3.1.jar:./plume.jar palus.main.OfflineMain --help

==Command Options==

View a complete list of Palus command? execute the following command: 

{{{java -cp ./palus-0.1.jar:./asm-all-3.1.jar:./plume.jar palus.main.OfflineMain --help}}}

*Basic options* for palus.main.OfflineMain:

|| *Option* || * Explanation* || *Default* || *Required?* ||
|| --time_limit || time for test generation (in seconds) || N/A || *Yes* ||
|| --class_file || a file containing all classes for test || N/A || *Yes* ||
|| --trace_file || a file containing all recorded event traces || N/A || *Yes* ||
|| --process_and_model_all_class || build model for each observed class. || false || No ||
|| --model_class_file || a file containing the classes to be modelled || N/A || No ||
|| --donot_build_model_from_trace || a flag. use already built model or not || false || No ||
|| --dont_process_all_trace || only process a part of recorded traces || false || No ||
|| --instance_per_model || number of object instances to process for each class model. || 20 || No ||
|| --auto_switch_to_random || automatically switch to random testing if the model coverage does not increase. || false || No ||
|| --switch_time_to_random || how long to switch if the model coverage does not increase. || 6000 msc || No ||
|| --percentage_of_random_gen || the percentage of random testing after exploring the model. || 4 || No ||
|| --only_random_uncovered_method || only random testing model-covered methods. || true || No ||
|| --dont_use_abstract_state_as_selector || use abstract object profile for argument selection || false || No ||
|| --dont_merge_equivalent_decorations || merge equivalent argument values for the observed method. || false || No ||
|| --print_model_coverage || print class model coverage at the end or not. || false || No ||
|| --exhaustive_diversify_seq || diversify the created sequence with every method in the same class|| false || No ||
|| --add_return_type_related_methods || add methods in the return type class as related ones. || false || No ||
|| --process_large_trace || process a large trace. || false || No ||
|| --use_theory_check || do oracle checking on a user-provided theory. || false || No ||
|| --check_npe || check null pointer exception or not. || true || No ||
|| --random_seed || change to a new random seed. || 0 || No ||
|| --dump_model_as_text || dump the built class model as text for inspection. || false || No ||
|| --save_trace_as_txt || save the observed traces as text for inspection. || false || No ||
|| --only_output_failed_tests || only output failed tests. || false || No ||
|| --filter_redundant_failures || remove redundant failed tests in the result. || false || No ||
|| --error_ignored_methods || a list of uninteresting method. ignore any errors in these methods. || null || No ||
|| --use_palulu_model || fall back to palulu (for experiment only) || false || No ||
|| --fall_back_to_randoop || fall back to randoop (for experiment only) || false || No ||


*Additional options * for palus.wrapper.PalusWrapperMain

PalusWrapperMain wraps the Palus process. It creates, monitors the Palus process, and restarts a new Palus process with a different random seed if it crashes. This wrapper process makes Palus more robust,since Palus may call some non-terminating or system calls (e.g. System.exit(int)) during test generation and then crashes.


|| *Option* || * Explanation* || *Default* || *Required?* ||
|| --spawner_timelimit || time limit for the Palus wrapper || N/A || *Yes* ||
|| --palus_class_path || a file containing all classes for test || System.getProperty("java.class.path", ".") || No ||
|| --java_command || Use which JVM to launch Palus || "java" (the default JVM in classpath) || No ||


==Examples==

=== Example 1 (a toy example) ===

The needed class files are included in the palus-0.1.jar.

1. put palus-0.1.jar in a folder, denoted as PALUS_DIR

2. download two dependent jars (plume.jar, asm-all-3.1.jar) from the download tab, and put them all into the PALUS_DIR folder

3. enter PALUS_DIR

4. run a sample execution:

   java -javaagent:./palus-0.1.jar=toydb -cp ./palus-0.1.jar:./asm-all-3.1.jar:$CLASSPATH database.Main

5. Palus will record the captured trace and save to a (binary) file in PALUS_DIR folder, named *toy_db_trace.model* (there might be another file called: toy_db_trace.txt. This is the human-readable trace text for error diagnose and performance tuning)

6. Download the toydatabase.txt file from the download tab. This file contains several classes to test for the toy example. Put this file to the PALUS_DIR.

   Execute the following command to generate tests:

   java -cp ./palus-0.1.jar:./asm-all-3.1.jar:./plume.jar palus.main.OfflineMain --time_limit 10 --class_file ./toydatabase.txt --trace_file ./toydb_trace.model

=== Example 2 (a real-world program: bcel 5.2 library) ===

The first 2 steps are the same with *Example 1*

1. put palus-0.1.jar in a folder, denoted as PALUS_DIR

2. download two dependent jars (plume.jar, asm-all-3.1.jar) from the download tab, and put them all into the PALUS_DIR folder

3. download the *bcel-5.2-exp.jar* from the download tab. Palus will generate tests for this library

4. enter PALUS_DIR

5. run a sample execution:

   java -javaagent:./palus-0.1.jar=bcel -cp ./palus-0.1.jar:./asm-all-3.1.jar:./bcel-5.2-exp.jar:$CLASSPATH org.apache.bcel.util.BCELifier org.apache.bcel.util.CodeHTML

6. Palus will record the captured trace and save to a (binary) file in PALUS_DIR folder, named *bcel_trace.model* (there might be another file called: bcel_trace.txt. This is the human-readable trace text for error diagnose and performance tuning)

7. Download the bcelclass.txt file from the download tab. This file contains all classes of the bcel library. Put this file to the PALUS_DIR.

   Execute the following command to generate tests:

   java -Xmx2G -cp ./palus-0.1.jar:./asm-all-3.1.jar:./plume.jar:./bcel-5.2-exp.jar palus.main.OfflineMain --time_limit 150 --class_file ./bcelclass.txt --trace_file ./bcel_trace.model --switch_time_to_random 6000 --process_large_trace

A group of *sample tests* (with *coverage chart*) generated by Palus in 20s, 50s, 100s, 150s respectively, in the experimental environment could be found [http://code.google.com/p/tpalus/source/browse/trunk/%20tpalus%20--username%20racezhang/Palus/bcelexperiment/bcel_generated_tests_coverage.tar.bz2 here]

*Notice: * The options *--switch_time_to_random 6000 * and *--process_large_trace* is used for efficient test generation for large trace files.

===where to find the generated tests?===

In the above 2 examples, all generated tests will reside in $PALUS_DIR/tests folder, under the tests package

===More examples===

*More examples* to evaluate Palus could be found [http://code.google.com/p/tpalus/wiki/MoreExamples here]


==Writing Project-Specific Testing Oracle for Effective Bug Finding==

Palus integrates the [http://dspace.mit.edu/bitstream/handle/1721.1/40090/MIT-CSAIL-TR-2008-002.pdf theory] framework in [http://www.junit.org/ JUnit] into the test generation engine. This permits programmers to write project-specific testing oracles, and Palus will automatically check its correctness during test generation.

Here is an example from the Junit theory [http://dspace.mit.edu/bitstream/handle/1721.1/40090/MIT-CSAIL-TR-2008-002.pdf theory] paper, suppose we are testing the bag data structure in apache-common-collections. We could write a general specification for the bag class as follows:

{{{
@RunWith(Theories.class)
public class ApacheCollectionTheory {
  @Theory
  public void bagAddItemToContainIt(Bag bag, Object item) {
   Assume.assumeTrue(bag != null && item !=null);
   try {
       bag.add(item);
   } catch (Exception e) {
     Assert.assertTrue(false);
   }
   Assert.assertTrue(bag.contains(item));
  }
}
}}}

The above simple theory specify the specification that each bag implementation should obey. That is, there should be no exception when adding non-null items to a bag, and after the add operation, the bag should contain the added item.

Users could simply put this class to the classlist.txt file as the input of Palus. Palus will automatically extract the theory and check its correctness, when it sees a Bag and Object instances during testing generation. This simple theory find several violations (bugs) in the latest apache-common release. Here is an example failed tests:

{{{

public void test414() throws Throwable {

    org.apache.commons.collections.TreeBag var0 = new org.apache.commons.collections.TreeBag();
    java.lang.Integer var1 = new java.lang.Integer(1);
    org.apache.commons.collections.ArrayStack var2 = new org.apache.commons.collections.ArrayStack(var1);
    java.lang.Class[] var3 = new java.lang.Class[] { };
    org.apache.commons.collections.Closure[] var4 = new org.apache.commons.collections.Closure[] { };
    org.apache.commons.collections.functors.ChainedClosure var5 = new org.apache.commons.collections.functors.ChainedClosure(var4);
    org.apache.commons.collections.functors.ChainedClosure var6 = new org.apache.commons.collections.functors.ChainedClosure(var4);
    java.lang.Object[] var7 = new java.lang.Object[] { var6};
    org.apache.commons.collections.functors.InstantiateTransformer var8 = new org.apache.commons.collections.functors.InstantiateTransformer(var3, var7);
    org.apache.commons.collections.functors.IdentityPredicate var9 = new org.apache.commons.collections.functors.IdentityPredicate((java.lang.Object)var8);
    org.apache.commons.collections.TreeBag var10 = new org.apache.commons.collections.TreeBag();
    boolean var11 = var9.evaluate((java.lang.Object)var10);
    org.apache.commons.collections.functors.EqualPredicate var12 = new org.apache.commons.collections.functors.EqualPredicate((java.lang.Object)var10);
    boolean var13 = org.apache.commons.collections.CollectionUtils.isSubCollection((java.util.Collection)var2, (java.util.Collection)var10);
    java.util.Iterator var14 = var10.iterator();
    boolean var15 = var0.removeAll((java.util.Collection)var10);
    
    try {
        new theory.ApacheCollectionTheory().bagAddItemToContainIt(var0, var10);
    } catch (java.lang.AssertionError ae) {
        fail("Theory checking: theory.ApacheCollectionTheory:public void theory.ApacheCollectionTheory.bagAddItemToContainIt(org.apache.commons.collections.Bag,java.lang.Object) fails");
    } catch (java.lang.Exception ex) {
        fail("Theory checking: theory.ApacheCollectionTheory:public void theory.ApacheCollectionTheory.bagAddItemToContainIt(org.apache.commons.collections.Bag,java.lang.Object) fails");
    }

  }

}}}

*Note*: please turn on the option *--use_theory_check* when starting Palus.

==Other Annotation Support==

Palus provides two annotations for test generation configuration

1. {{{palus.testgen.ParamValue}}} annotation permits programmers to specify (additional) parameter values for a specific method. Here is an example:

   {{{
    @ParamValue(className = "database.Statement",methodName = "execute")
    public static String string1 = "drop table TEST";
   
    @ParamValue(className = "database.Statement",methodName = "execute")
    public static String string2 = "select * from TEST";
   }}}

   The above two annotations specify two additional parameter values for the {{{execute}}} method in class {{{database.Statement}}}. Such highly constrained values are hard to generated by an automated tool. When generating tests, Palus will give high priority in using the user-specified values for a certain tested method.

2. {{{palus.testgen.IgnorableMethod}}} annotation permits programmers to specify ignored method during test generation. For instance,

   {{{
    @IgnorableMethod
    public void someMethod() {...}
   }}}
    
   During test generation, Palus will not call the above specified method for test generation. This annotation gives programmer more flexibility in choosing which method to test.

= How to measure test coverage? =

We use [http://cobertura.sourceforge.net/ cobertura] (version 1.9.4.1) to measure the line/branch coverage of generated unit tests. A good instruction of how to use cobertura could be found [http://cobertura.sourceforge.net/commandlinereference.html here].